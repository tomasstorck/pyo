#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Visit github.com/tomasstorck/pyo for updates and more information.

import os
import sys
import subprocess
import time
import pickle
import argparse
import configparser

###########

# Load a few commonly used variables
homeDir = os.path.expanduser('~')
DBDir = homeDir + "/.cache/pyo"
defaultPathArray = [homeDir, '/usr/bin']

###########

t0 = time.time()
# Parse configuration file
config = configparser.ConfigParser(comment_prefixes=(';',), inline_comment_prefixes=(';',))           # Allow comments using ';'. # is reserved for colours
if config.read(homeDir + "/.config/pyo/settings") == []:
    raise FileNotFoundError("Configuration file does not exist, download using e.g. 'wget https://github.com/tomasstorck/pyo/raw/master/pyo -O " + homeDir + "/.config/pyo/settings'")
else:
    # TODO: throw error when below settings do not exist (try/catch)
    dmenu_args      = config['dmenu']['arguments'].splitlines()
    blacklist_dir   = config['blacklist']['dir'].split()
    blacklist_file  = config['blacklist']['file'].split()
    Nrecent         = int(config['other']['Nrecent'])
    # TODO: throw warning when unused settings are defined
    print("read configuration file in " + str(round(time.time() - t0, 3)) + " s")

###########

def buildFiles(pathArray):
    t0 = time.time()
    # Initialise empty database
    filesDB = {}
    print("updating 'files' database...")

    for p in pathArray:
        # Walk recursively through files in pathArray, compile database
        for root, dirs, files in os.walk(p, topdown=True):
            # Filter out the unwanted directories
            for d in dirs[:]:  # dirs[:] to make a copy of dirs
                if any(bl in d for bl in blacklist_dir):
                    dirs.remove(d)
            # Loop through these files and append if interesting (does not start with . and is not in blacklist)
            for f in files[:]:
                if not f[0] == '.' and not any(bl in f for bl in blacklist_file):
                    # See if file is executable. Store as script if so, as file otherwise (using xdg-open)
                    if os.access(os.path.join(root, f), os.X_OK):
                        filesDB[f] = [os.path.join(root, f)]
                    else:
                        filesDB[f] = ['xdg-open', os.path.join(root, f)]

    print("updated 'files' database in " + str(round(time.time() - t0, 3)) + " s")

    return filesDB


###########

def saveFiles(filesDB, DBName='pyoFiles'):
    t0 = time.time()
    with open(DBDir + '/' + DBName + '.pkl', 'wb') as fid:  # w = write, b = binary
        print("saved 'files' database in " + str(round(time.time() - t0, 3)) + " s")
        pickle.dump(filesDB, fid,
                    pickle.HIGHEST_PROTOCOL)  # Python 3 will choose whether to use pure Python pickle or cPickle


###########

def loadFiles():
    t0 = time.time()
    filesDB = {}
    try:
        with open(DBDir + '/pyoFiles.pkl', 'rb') as fid:  # r = read, b = binary
            filesDB = pickle.load(fid)
    except IOError as e:
        raise e from FileNotFoundError("Could not find file system database, generate using \'pyo -u\'")
    print("loaded 'files' database in " + str(round(time.time() - t0, 3)) + " s")
    return filesDB


###########

def saveRecent(recentDB):
    t0 = time.time()
    with open(DBDir + '/pyoRecent.pkl', 'wb') as fid:  # w = write, b = binary
        pickle.dump(recentDB, fid, pickle.HIGHEST_PROTOCOL)
    print("saved 'recent' database in " + str(round(time.time() - t0, 3)) + " s")


###########

def loadRecent():
    t0 = time.time()
    try:
        with open(DBDir + '/pyoRecent.pkl', 'rb') as fid:  # r = read, b = binary
            recentDB = pickle.load(fid)
    except IOError:
        print("WARNING: Could not find recent database, using empty database")
        return []
    print("loaded 'recent' database in " + str(round(time.time() - t0, 3)) + " s")
    return recentDB


###########

def appendRecentIfNeeded(cmd, recentDB):
    t0 = time.time()
    # See if we should append the chosen key to recent
    append = True
    if cmd == '':
        append = False
    for i in range(len(recentDB)):
        r = recentDB[i]
        if cmd == r:
            recentDB.pop(i)  # we'll add it again in the next step
            break  # there is only one command, so no point continuing

    # Append if needed
    if append:
        Npop = len(recentDB) + 1 - Nrecent
        for i in range(Npop):
            recentDB.pop(0)  # Pop oldest key
        recentDB.append(cmd)
        print("updated 'recent' database in " + str(round(time.time() - t0, 3)) + " s")
        saveRecent(recentDB)
    

###########

def builddmenu(filesDB, recentDB=['']):
    t0 = time.time()

    # Build bash echo string
    echoStr = ''
    for k in recentDB[::-1]:
        echoStr += k + '\n'

    keys = list(filesDB.keys())
    keys.sort()
    for k in keys:
        if not k in recentDB:
            echoStr += k + '\n'

    print("built dmenu input in " + str(round(time.time() - t0, 3)) + " s")

    return echoStr


###########

def calldmenu(echoStr):
    # Communicate with dmenu through the shell
    p = subprocess.Popen(['dmenu'] + dmenu_args,  # Concatenate dmenu with its arguments
                         stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    stdout, stderr = p.communicate(
        input=echoStr.encode())  # Call subprocess, piping in the bytes version of the menu input
    cmd = stdout.strip().decode()  # Decode to go from bytes --> str

    # Work through command returned by dmenu
    if cmd == '':
        print("Stopped without command")
    elif cmd in filesDB:
        subprocess.Popen(filesDB[cmd], stdin=None, stdout=None, stderr=None)
    else:
        # Convert command to an array
        cmdArray = cmd.split(' ')
        cmdArrayProc = []  # copy cmdArray so we can make the changes in there
        # Find out if there is a key in the given command. No worries if not, then it's just an argument
        for i in range(len(cmdArray)):
            c = cmdArray[i]
            if c in filesDB:
                cmdArrayProc.append(*filesDB[c])
            else:
                cmdArrayProc.append(c)
        # Now execute the processed command
        subprocess.Popen(cmdArrayProc, stdin=None, stdout=None, stderr=None)

    return cmd

######################

# Analyse input arguments
parser = argparse.ArgumentParser(description="Search for and open a file or program using dmenu", 
                                 epilog="See github.com/tomasstorck/pyo for details.")
parser.add_argument('-o', 
                    help = "start pyo and commence searching (default)",
                    action = 'store_true')
parser.add_argument('-u', metavar='PATH',
                    help = "save contents of specified paths into database (" + ", ".join(defaultPathArray) + " unless specified)",
                    nargs = '*')
parserArgs = parser.parse_args()

# However, we walk through sys.argv to maintain the order instead of using the parser
for arg in sys.argv:
    if len(sys.argv) == 1 or arg in ['-o']:
        # Load specified databases
        filesDB = loadFiles()
        # Continue creating dmenu and appending to recent
        recentDB = loadRecent()
        echoStr = builddmenu(filesDB, recentDB)
        cmd = calldmenu(echoStr)
        print("running '" + cmd + "'")
        appendRecentIfNeeded(cmd, recentDB)

    # build and save file system database
    elif arg in ['-u']:
        pathArray = parserArgs.u
        if pathArray == []:                         # Use default pathArray if otherwise empty
            pathArray = defaultPathArray
        filesDB = buildFiles(pathArray)
        saveFiles(filesDB)
    # build and save recent system database
    elif arg in ['--reset-recent']:
        # define empty, dummy database
        print("creating dummy recent database")
        recentDB = []
        saveRecent(recentDB)
